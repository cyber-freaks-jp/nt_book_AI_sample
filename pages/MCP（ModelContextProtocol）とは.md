# MCP（Model Context Protocol）とは

これまで、AIエージェントが様々なツールを使って作業を進めることを学びました。

しかし、AIエージェントがツールを使うためには、ある重要な仕組みが必要です。それが「MCP（Model Context Protocol）」です。

## AIエージェントがツールを使う仕組み

まず、AIエージェントがどのようにツールを使っているのか、見てみます。

### AIエージェントが使うツールの例

AIエージェントは、様々なツールを使います。

- **カレンダー**：予定を追加、確認、削除
- **メール**：メールの送信、受信、検索
- **データベース**：データの検索、追加、更新
- **Web検索**：最新情報の取得
- **ファイル操作**：ファイルの読み書き、編集

これらのツールは、それぞれ異なるサービスやアプリケーションです。

### ツールごとに使い方が違う問題

ここで問題があります。

**ツールごとに使い方が違う**のです。

たとえば、カレンダーアプリは「カレンダーA社」と「カレンダーB社」で、使い方が違います。

```
カレンダーA社の使い方：
- 予定追加： add_event(title, date, time)
- 予定確認： get_events(date)

カレンダーB社の使い方：
- 予定追加： create_schedule(event_name, datetime)
- 予定確認： list_schedules(from_date, to_date)
```

つまり、**同じ「カレンダー」でも、使い方が全く違う**のです。

### AIエージェントの困りごと

AIエージェントが100種類のツールを使おうとすると、こうなります。

```
AIエージェント：「100種類のツールの使い方を全部覚えないといけない...」
```

これでは大変です。ツールが増えるたびに、AIエージェントに新しい使い方を教える必要があります。

## MCPという解決策

この問題を解決するのが「MCP（Model Context Protocol）」です。

MCPは、**AIエージェントとツールが共通のルールで会話するための約束事**です。

### MCPのイメージ：コンセントの規格

MCPをわかりやすく言うと、「コンセントの規格」のようなものです。

**コンセントがない世界を想像してください：**

```
冷蔵庫：専用のプラグ形状
テレビ：専用のプラグ形状
洗濯機：専用のプラグ形状
```

これでは大変です。家電を買うたびに、専用のコンセントを設置する必要があります。

**現実の世界（コンセントの規格がある）：**

```
冷蔵庫、テレビ、洗濯機：すべて同じコンセント形状
→ どの家電も、壁のコンセントに挿せば使える
```

MCPも同じです。

**MCPがない世界：**

```
AIエージェント：カレンダーA社の使い方を覚える
AIエージェント：カレンダーB社の使い方を覚える
AIエージェント：メールC社の使い方を覚える
```

**MCPがある世界：**

```
すべてのツールがMCPに対応
→ AIエージェントは、MCPのルールさえ知っていれば、どんなツールも使える
```

### MCPの仕組み

MCPでは、ツールとAIエージェントが次のように会話します。

**1. AIエージェントがツールに問い合わせる**

```
AIエージェント：「あなたは何ができますか？」

カレンダーツール：
「私はカレンダーツールです。次の機能があります」
- 予定追加（タイトル、日付、時刻が必要）
- 予定確認（日付が必要）
- 予定削除（予定IDが必要）
```

**2. AIエージェントが機能を理解する**

```
AIエージェント：
「なるほど、このツールは予定追加ができるんだな」
「タイトル、日付、時刻を渡せばいいんだな」
```

**3. AIエージェントが必要に応じて実行する**

```
ユーザー：「明後日14時に会議の予定を入れて」

AIエージェント → カレンダーツール：
「予定を追加してください」
- タイトル：「会議」
- 日付：「2025-10-30」
- 時刻：「14:00」

カレンダーツール → AIエージェント：
「追加しました」

AIエージェント → ユーザー：
「会議の予定を10月30日14時に追加しました」
```

このやりとりが、**MCPという共通のルールで行われる**のです。

つまり、MCPは次の3つのステップで動きます：

1. **発見**：AIエージェントが「何ができるか」をツールに聞く
2. **理解**：ツールが「自分の機能」を説明する
3. **実行**：AIエージェントがツールに命令を送り、ツールが実行する

## MCPのメリット

MCPがあることで、様々なメリットがあります。

### 1. ツールを簡単に追加できる

新しいツールを追加する場合、MCPに対応させるだけで、すぐにAIエージェントが使えるようになります。

```
新しいツール：「MCPに対応しました」
AIエージェント：「すぐに使えます！」
```

MCPがなければ、新しいツールを追加するたびに、AIエージェント側の設定を変更する必要がありました。

### 2. どのAIエージェントでも使える

MCPに対応したツールは、MCPに対応したAIエージェントなら、どれでも使えます。

```
カレンダーツール（MCP対応）
→ AIエージェントA、B、C、すべてで使える
```

### 3. ツールを入れ替えやすい

同じ機能を持つツールなら、簡単に入れ替えられます。

```
カレンダーA社からカレンダーB社に変更
→ どちらもMCP対応なので、すぐに切り替えられる
```

## MCPとAPIの違い

エンジニアの方は、「それってAPIと何が違うの？」と思うかもしれません。具体的なコードで比較してみましょう。

### 従来のAPI：決められたインターフェースしか使えない

カレンダーAPIを使うとき、開発者はこう書きます。

```javascript
// カレンダーAPIのドキュメントを見て、このように実装
async function addEvent(title, date, time) {
  const response = await fetch('https://api.calendar.com/v1/events', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ title, date, time })
  });
  return response.json();
}

// 使うとき
addEvent('会議', '2025-10-30', '14:00');
```

この場合：
- **エンドポイント（`/v1/events`）が決まっている**
- **メソッド（`POST`）が決まっている**
- **パラメータ（`title`, `date`, `time`）が決まっている**
- **これ以外のことはできない**（例：予定の色を変えたくても、APIに無ければ不可能）

### MCP：自己記述的で拡張可能なインターフェース

MCPサーバー側では、開発者はツールが「何ができるか」を記述するだけです。

```javascript
// MCPサーバー側：ツールの定義
const calendarTool = {
  name: "add_calendar_event",
  description: "カレンダーに予定を追加する",
  parameters: {
    title: { type: "string", description: "予定のタイトル" },
    date: { type: "string", description: "日付 (YYYY-MM-DD)" },
    time: { type: "string", description: "時刻 (HH:MM)" },
    color: { type: "string", description: "予定の色（オプション）", optional: true }
  },
  execute: async (params) => {
    // 実際の処理
    return `予定「${params.title}」を${params.date} ${params.time}に追加しました`;
  }
};

// MCPサーバーは、このツールの情報をAIエージェントに提供
```

呼び出し側（AIエージェント側）では、こう使います。

```javascript
// AIエージェント側（疑似コード）
// 1. MCPサーバーに接続して、利用可能なツールを取得
const tools = await mcpServer.listTools();
// → [{ name: "add_calendar_event", description: "...", parameters: {...} }]

// 2. ユーザーの自然言語入力を受け取る
const userInput = "明日14時に会議の予定を入れて。色は赤で";

// 3. AIエージェントが判断
// - どのツールを使うか？ → add_calendar_event
// - パラメータは何か？ → title="会議", date="2025-10-27", time="14:00", color="赤"

// 4. 実行
const result = await mcpServer.callTool("add_calendar_event", {
  title: "会議",
  date: "2025-10-27",
  time: "14:00",
  color: "赤"
});
```

### 本質的な違い

#### **API：開発者が全部書く**

```javascript
// ユーザー入力: "明日14時に会議"
// 開発者が自分で実装する必要がある
const tomorrow = new Date();
tomorrow.setDate(tomorrow.getDate() + 1);
const dateStr = tomorrow.toISOString().split('T')[0];

addEvent('会議', dateStr, '14:00');
```

- 開発者が「明日」を計算するコードを書く
- 開発者が「14時」を解釈するコードを書く
- 開発者がAPIを呼び出すコードを書く

#### **MCP：AIエージェントが判断して実行**

```javascript
// ユーザー入力: "明日14時に会議"
// AIエージェントに渡すだけ
await aiAgent.execute("明日14時に会議");

// AIエージェント内部で：
// 1. 「明日」→ 日付計算
// 2. 「14時」→ "14:00"
// 3. add_calendar_event を選択
// 4. パラメータを構築して実行
```

### まとめ

| 項目 | 従来のAPI | MCP |
|------|-----|-----|
| インターフェース | 固定（エンドポイント、メソッド、パラメータが決まっている） | 自己記述的（ツールが自分の機能を説明する） |
| 呼び出し | 開発者がコードで明示的に記述 | AIエージェントが自然言語から判断して実行 |
| 拡張性 | APIに無い機能は使えない | ツール側で機能を追加すれば、AIエージェントが自動で理解して使える |
| パラメータ抽出 | 開発者が実装 | AIエージェントが自然言語から推論 |

**APIは「決められたことしかできない」、MCPは「ツールができることを自己記述して、AIエージェントがそれを理解して使う」**

これにより、開発者は「カレンダーに予定を追加する」という機能だけを定義すれば、AIエージェントが自然言語から適切にパラメータを判断して実行してくれます。

## MCPの活用例

MCPは、様々な場面で活用されています。

### 例1：カレンダー連携

**やりたいこと：**
「来週の月曜日、午後2時に会議の予定を入れて」

### 例2：メール送信

**やりたいこと：**
「田中さんに、プロジェクトの進捗を報告するメールを送って」

### 例3：データベース検索

**やりたいこと：**
「先月の売上データを取得して、グラフを作って」

## AI駆動開発におけるMCP：何が嬉しいのか？

「それってAPIでもできるじゃん」と思うかもしれません。しかし、MCPの真価は**複数のツールを組み合わせて使うとき**に発揮されます。

### APIだけだと何が大変なのか

従来のAPIを使う場合、開発者がすべての統合コードを書く必要があります。

```javascript
// 例：「バグを修正してテストしてコミットする」を自動化したい場合

// 1. バグレポートを取得（Jira API）
const bug = await jira.getIssue('BUG-123');

// 2. コードを修正（VSCode API）
await vscode.openFile(bug.file);
// ... 修正コードを書く（これは開発者が手動で書く）

// 3. テストを実行（Jest API）
const testResult = await jest.run(bug.testFile);

// 4. 成功したらコミット（Git API）
if (testResult.success) {
  await git.add(bug.file);
  await git.commit(`Fix ${bug.id}: ${bug.title}`);
  await git.push();

  // 5. Jiraを更新（Jira API）
  await jira.updateIssue(bug.id, { status: 'Done' });
}
```

この場合：
- **開発者が各APIの使い方を調べる**
- **開発者が統合コードを書く**
- **開発者がエラー処理を書く**
- **Jira、VSCode、Jest、Gitの各APIに精通している必要がある**

### MCPがあると何が嬉しいのか

すべてのツールがMCPに対応していれば、AIエージェントに指示するだけです。

これならとっても楽ですね！

```javascript
// AIエージェントに指示
await aiAgent.execute("BUG-123を修正して、テストして、コミットして");

// AIエージェント内部で：
// 1. MCPサーバーから利用可能なツールを取得
//    → jira_get_issue, code_modify, test_run, git_commit, jira_update
//
// 2. AIが実行計画を立てる
//    → まずJiraからバグ情報を取得
//    → 該当ファイルを開いて修正
//    → テストを実行
//    → 成功したらコミット
//    → Jiraを更新
//
// 3. 各ツールを順番に実行
// 4. エラーが出たら自分で対処を試みる
```

## MCPの現実と未来

ここまでMCPの素晴らしさを説明してきましたが、新しい技術のため現実には課題もあります。

### 現実1：サービス提供側が対応している必要がある

MCPは、APIと同じく、**サービス提供側が対応していないと使えません**。

#### APIの場合

```javascript
// GitHubがAPIを提供している
await github.createIssue({ title: "バグ修正", body: "..." });

// Slackがカを提供している
await slack.sendMessage({ channel: "#general", text: "..." });
```

これらは、GitHub社やSlack社が「APIを提供しよう」と決めて、開発・公開したから使えるわけです。

#### MCPも同じ

```javascript
// GitHubがMCPサーバーを提供していれば
await mcpServer.callTool("github_create_issue", { ... });

// SlackがMCPサーバーを提供していれば
await mcpServer.callTool("slack_send_message", { ... });
```

MCPも、GitHub社やSlack社が「MCPサーバーを作ろう」と決めて、開発・公開する必要があります。

### 現実2：MCP対応はまだ少ない

MCPは2024年頃に登場した新しい技術です。2025年現在、MCPに対応しているサービスは限られています。

つまり、**「すべてのツールがMCP対応している」という理想の世界は、まだ来ていません**。

### 自分でMCPサーバーを作ることもできる

ただし、MCPはオープンな仕様なので、**自分でMCPサーバーを作ることができます**。

```javascript
// 例：GitHub APIをラップしたMCPサーバーを自作
const githubMCPServer = {
  tools: [
    {
      name: "github_create_issue",
      description: "GitHubにIssueを作成",
      parameters: { ... },
      execute: async (params) => {
        // 内部ではGitHub APIを呼び出す
        return await github.api.createIssue(params);
      }
    }
  ]
};
```

これにより、GitHub公式がMCP対応していなくても、自分でMCPサーバーを作れば、AIエージェントから使えるようになります。

### APIとMCPの普及の比較

| 項目 | API | MCP |
|------|-----|-----|
| 登場時期 | 2000年代から | 2024年頃から |
| 対応サービス | ほとんどの主要サービスが提供 | まだ少ない |
| 自作の難易度 | 高い（クライアントライブラリを作る必要） | 低い（MCPサーバーの定義だけ） |
| 将来性 | すでに普及済み | これから普及する可能性 |

### 現実的な使い方

現時点では、以下のような使い方が現実的です。

1. **MCP対応しているツールを優先的に使う**
   - Claude Codeなど、MCP対応済みのツールを活用

2. **よく使うサービスは自分でMCPサーバーを作る**
   - 社内ツールやよく使うAPIをMCPでラップする

3. **APIとMCPを併用する**
   - MCP対応していないサービスは従来通りAPIで使う
   - MCP対応しているサービスはMCPで使う


### エンジニアとして押さえておくべきポイント

- **MCPは2024年頃に登場した新しい技術**
- **まだ発展途上で、対応サービスは少ない**
- **サービス提供側が対応する必要がある**（APIと同じ）
- **自分でMCPサーバーを作ることもできる**
- **今後普及する可能性がある**技術として注目されている
- **現時点では、APIとMCPを併用する**のが現実的

MCPは、AIエージェントの可能性を大きく広げる技術です。現時点ではまだ発展途上ですが、今後の普及が期待されています。
